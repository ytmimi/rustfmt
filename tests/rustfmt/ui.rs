use super::rustfmt;
use rustfmt_nightly::test_helpers::{get_test_files, read_significant_comments};
use std::path::{Path, PathBuf};

/// Transforms the `// rustfmt-{config}: {value}` comments in each test file into a String
/// that can be passed to rustfmt on the command line like
/// `--config={config1}={value1},{config2}={value2}
fn command_line_args_from_significant_comments(path: &Path) -> String {
    let config_comments = read_significant_comments(path);

    if config_comments.is_empty() {
        return String::new();
    }

    let mut config = String::with_capacity(256);
    config.push_str("--config=");

    let mut iter = config_comments.into_iter().peekable();

    while let Some((key, value)) = iter.next() {
        if key == "config" || key == "target" {
            continue;
        }

        let is_last = iter.peek().is_none();

        config.push_str(&key);
        config.push('=');
        config.push_str(&value);

        if !is_last {
            config.push(',')
        }
    }
    config
}

enum CheckOutputResult {
    /// The output matches what's in the expected file
    Okay,
    /// The expected file doesn't exist and there was no output generated by rustfmt
    NothingToCheck,
    /// The output generated by rustfmt doesn't match what's in the expected file
    MismatchedContent,
    /// rustfmt generated output but the expected output file does not exist
    MissingExpectedFile,
}

/// Compares the input against the output read from a file.
/// returns `true` if the check was successfull, and `false` otherwise.
fn check_output_file(output: &str, expected: &Path) -> CheckOutputResult {
    match (expected.exists(), !output.is_empty()) {
        (true, _) => {
            // The file exists so compare it's content with the output.
            let expected_output =
                std::fs::read_to_string(expected).expect("to read the file successfully");
            if expected_output.trim() == output.trim() {
                CheckOutputResult::Okay
            } else {
                CheckOutputResult::MismatchedContent
            }
        }
        (false, true) => {
            // The file does not exist and the output is not empty.
            CheckOutputResult::MissingExpectedFile
        }
        (false, false) => {
            // The file doesn't exist, and the output isn't empty
            CheckOutputResult::NothingToCheck
        }
    }
}

fn ui_test_inner(files: Vec<PathBuf>, args: Vec<&str>, check_stdout: bool, check_stderr: bool) -> usize {
    if !check_stderr && !check_stdout {
        panic!("We need to check stdout, stderr, or both");
    }

    let mut errors = 0;

    let has_errors = |rustfmt_output: &str, output_file: &Path| -> bool {
        match check_output_file(&rustfmt_output, &output_file) {
            CheckOutputResult::Okay | CheckOutputResult::NothingToCheck => false,
            CheckOutputResult::MissingExpectedFile => {
                eprintln!("Missing {}", output_file.display());
                eprintln!("Expected content: {}", rustfmt_output);
                true
            }
            CheckOutputResult::MismatchedContent => {
                eprintln!(
                    "Expected {} to contain\n{}",
                    output_file.display(),
                    rustfmt_output
                );
                true
            }
        }
    };

    for file in files {
        let config = command_line_args_from_significant_comments(&file);
        let mut args = args.clone();
        args.push(config.as_str());
        args.push(file.to_str().unwrap());

        // deprecation warnings are only emitted on stderr
        let (stdout, stderr) = rustfmt(&args);

        if check_stdout {
            let stdout_file = file.with_extension("stdout");
            errors += has_errors(&stdout, &stdout_file) as usize;
        }

        if check_stderr {
            let stderr_file = file.with_extension("stderr");
            errors += has_errors(&stderr, &stderr_file) as usize;
        }
    }

    errors
}

fn default_ui_test_configs() -> Vec<&'static str> {
    vec![
        "--color=Never",
        // The root `rustfmt.toml` file was being picked up so we specify a blank file
        "--config-path=tests/config/no_config.toml",
        // we don't want to overwrite the files
        "--check",
    ]
}

/// Check the output for deprecated warnings
#[test]
fn deprecated() {
    let files = get_test_files(&PathBuf::from("tests/ui/deprecated"), true, &[]);
    let args  = default_ui_test_configs();
    let errors = ui_test_inner(files, args, false, true);
    assert!(errors == 0, "All deprecation UI tests should pass")
}
